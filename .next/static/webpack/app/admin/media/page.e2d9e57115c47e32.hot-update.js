"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/media/page",{

/***/ "(app-pages-browser)/./src/app/admin/hooks/useMediaManager.ts":
/*!************************************************!*\
  !*** ./src/app/admin/hooks/useMediaManager.ts ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMediaManager: () => (/* binding */ useMediaManager)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// src/app/admin/hooks/useMediaManager.ts\n\n// Fonction de normalisation des tags\nconst normalizeTags = (tags)=>{\n    if (!tags) return []; // Gère null ou undefined\n    if (Array.isArray(tags)) {\n        return tags.flatMap((tag)=>tag.split(',').map((t)=>t.trim())).filter((t)=>t.length > 0);\n    }\n    const trimmed = tags.trim();\n    if (trimmed === 'null' || trimmed === '') return []; // Gère \"null\" ou chaîne vide\n    if (trimmed.startsWith('[') && trimmed.endsWith(']')) {\n        try {\n            const parsed = JSON.parse(trimmed);\n            if (Array.isArray(parsed)) {\n                return parsed.flatMap((tag)=>typeof tag === 'string' ? tag.split(',').map((t)=>t.trim()) : []).filter((t)=>t.length > 0);\n            }\n        } catch (e) {\n            console.error('Error parsing JSON tags:', e);\n        }\n    }\n    return trimmed.split(/[,\\s]+/).map((t)=>t.trim()).filter((t)=>t.length > 0);\n};\nfunction useMediaManager(extendedSession) {\n    const [media, setMedia] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [pendingFiles, setPendingFiles] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [folders, setFolders] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([\n        {\n            name: 'Dossier principal',\n            media: []\n        }\n    ]);\n    const [currentFolder, setCurrentFolder] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('Dossier principal');\n    const [selectedMedia, setSelectedMedia] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [tags, setTags] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [selectedTagInput, setSelectedTagInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [description, setDescription] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Synchronise tags et description lorsque selectedMedia change, avec logs détaillés\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMediaManager.useEffect\": ()=>{\n            if (selectedMedia) {\n                console.log('Selected media changed (before update):', {\n                    selectedMedia,\n                    currentTags: tags,\n                    currentDescription: description\n                });\n                const newTags = normalizeTags(selectedMedia.tags);\n                const newDescription = selectedMedia.description || '';\n                console.log('Updating tags and description:', {\n                    newTags,\n                    newDescription\n                });\n                setTags(newTags);\n                setDescription(newDescription);\n                setSelectedTagInput(''); // Réinitialise l'input des tags\n                console.log('Updated states:', {\n                    tags: newTags,\n                    description: newDescription\n                });\n            } else {\n                console.log('No selected media, resetting states');\n                setTags([]);\n                setDescription('');\n                setSelectedTagInput('');\n            }\n        }\n    }[\"useMediaManager.useEffect\"], [\n        selectedMedia\n    ]);\n    const loadMedia = async ()=>{\n        setIsLoading(true);\n        try {\n            console.log('Loading media...');\n            const res = await fetch('/api/media');\n            if (!res.ok) throw new Error(\"Failed to fetch media: \".concat(res.status));\n            const data = await res.json();\n            console.log('Raw media data:', data); // Log complet pour voir la structure\n            const { media: mediaData } = data;\n            // Traitement des médias avec normalisation des tags et description\n            const processedMedia = mediaData.map((item)=>({\n                    ...item,\n                    tags: normalizeTags(item.tags),\n                    description: item.description || ''\n                }));\n            console.log('Processed media with tags and description:', processedMedia);\n            setMedia(processedMedia);\n            updateFolders(processedMedia); // Utiliser les médias traités ici\n        } catch (err) {\n            console.error(err);\n            setError('Erreur lors du chargement des médias');\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    const updateFolders = (mediaList)=>{\n        const folderMap = {};\n        mediaList.forEach((mediaItem)=>{\n            const folderName = mediaItem.associated_with || 'Dossier principal';\n            if (!folderMap[folderName]) folderMap[folderName] = [];\n            folderMap[folderName].push(mediaItem);\n        });\n        setFolders(Object.entries(folderMap).map((param)=>{\n            let [name, media] = param;\n            return {\n                name,\n                media\n            };\n        }));\n        if (!folderMap[currentFolder]) {\n            setCurrentFolder('Dossier principal');\n        }\n    };\n    const uploadFiles = async ()=>{\n        setIsLoading(true);\n        try {\n            for (const pendingFile of pendingFiles){\n                const formData = new FormData();\n                formData.append('files', pendingFile.file);\n                formData.append('userId', extendedSession.user.id);\n                formData.append('type', 'media');\n                formData.append('folder', pendingFile.folder);\n                formData.append('tags', JSON.stringify(pendingFile.tags));\n                formData.append('description', pendingFile.description);\n                const res = await fetch('/api/uploads', {\n                    method: 'POST',\n                    body: formData\n                });\n                if (!res.ok) throw new Error(\"Failed to upload file \".concat(pendingFile.file.name, \": \").concat(res.status));\n            }\n            setPendingFiles([]);\n            await loadMedia();\n            setError(null);\n        } catch (err) {\n            console.error(err);\n            setError('Erreur lors de l’upload des fichiers');\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    const saveMediaEdits = async ()=>{\n        if (selectedMedia) {\n            try {\n                const res = await fetch('/api/media', {\n                    method: 'PUT',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        id: selectedMedia.id,\n                        folder: currentFolder,\n                        tags: tags,\n                        description: description\n                    })\n                });\n                if (!res.ok) throw new Error(\"Failed to update media: \".concat(res.status));\n                await loadMedia();\n                setSelectedMedia(null);\n                setTags([]);\n                setDescription('');\n                setSelectedTagInput('');\n            } catch (err) {\n                console.error(err);\n                setError('Erreur lors de la mise à jour du média');\n            }\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useMediaManager.useEffect\": ()=>{\n            if (extendedSession && extendedSession.user) {\n                loadMedia();\n            }\n        }\n    }[\"useMediaManager.useEffect\"], [\n        extendedSession\n    ]);\n    return {\n        media,\n        pendingFiles,\n        folders,\n        currentFolder,\n        selectedMedia,\n        tags,\n        selectedTagInput,\n        description,\n        isLoading,\n        error,\n        setPendingFiles,\n        setCurrentFolder,\n        setSelectedMedia,\n        setTags,\n        setSelectedTagInput,\n        setDescription,\n        loadMedia,\n        uploadFiles,\n        updateFolders,\n        saveMediaEdits,\n        setError\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvYWRtaW4vaG9va3MvdXNlTWVkaWFNYW5hZ2VyLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHlDQUF5QztBQUNHO0FBWTVDLHFDQUFxQztBQUNyQyxNQUFNRSxnQkFBZ0IsQ0FBQ0M7SUFDckIsSUFBSSxDQUFDQSxNQUFNLE9BQU8sRUFBRSxFQUFFLHlCQUF5QjtJQUMvQyxJQUFJQyxNQUFNQyxPQUFPLENBQUNGLE9BQU87UUFDdkIsT0FBT0EsS0FDSkcsT0FBTyxDQUFDLENBQUNDLE1BQWdCQSxJQUFJQyxLQUFLLENBQUMsS0FBS0MsR0FBRyxDQUFDLENBQUNDLElBQU1BLEVBQUVDLElBQUksS0FDekRDLE1BQU0sQ0FBQyxDQUFDRixJQUFNQSxFQUFFRyxNQUFNLEdBQUc7SUFDOUI7SUFDQSxNQUFNQyxVQUFVWCxLQUFLUSxJQUFJO0lBQ3pCLElBQUlHLFlBQVksVUFBVUEsWUFBWSxJQUFJLE9BQU8sRUFBRSxFQUFFLDZCQUE2QjtJQUNsRixJQUFJQSxRQUFRQyxVQUFVLENBQUMsUUFBUUQsUUFBUUUsUUFBUSxDQUFDLE1BQU07UUFDcEQsSUFBSTtZQUNGLE1BQU1DLFNBQVNDLEtBQUtDLEtBQUssQ0FBQ0w7WUFDMUIsSUFBSVYsTUFBTUMsT0FBTyxDQUFDWSxTQUFTO2dCQUN6QixPQUFPQSxPQUNKWCxPQUFPLENBQUMsQ0FBQ0MsTUFBYyxPQUFPQSxRQUFRLFdBQVdBLElBQUlDLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRUMsSUFBSSxNQUFNLEVBQUUsRUFDekZDLE1BQU0sQ0FBQyxDQUFDRixJQUFNQSxFQUFFRyxNQUFNLEdBQUc7WUFDOUI7UUFDRixFQUFFLE9BQU9PLEdBQUc7WUFDVkMsUUFBUUMsS0FBSyxDQUFDLDRCQUE0QkY7UUFDNUM7SUFDRjtJQUNBLE9BQU9OLFFBQVFOLEtBQUssQ0FBQyxVQUFVQyxHQUFHLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRUMsSUFBSSxJ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QUFFLE9BQU9rQixLQUFLO1lBQ1p4QyxRQUFRQyxLQUFLLENBQUN1QztZQUNkbEIsU0FBUztRQUNYLFNBQVU7WUFDUkQsYUFBYTtRQUNmO0lBQ0Y7SUFFQSxNQUFNeUMsaUJBQWlCO1FBQ3JCLElBQUlqRCxlQUFlO1lBQ2pCLElBQUk7Z0JBQ0YsTUFBTWdCLE1BQU0sTUFBTUMsTUFBTSxjQUFjO29CQUNwQzhCLFFBQVE7b0JBQ1JHLFNBQVM7d0JBQUUsZ0JBQWdCO29CQUFtQjtvQkFDOUNGLE1BQU1oRSxLQUFLOEQsU0FBUyxDQUFDO3dCQUNuQkYsSUFBSTVDLGNBQWM0QyxFQUFFO3dCQUNwQkMsUUFBUS9DO3dCQUNSN0IsTUFBTUE7d0JBQ05vQyxhQUFhQTtvQkFDZjtnQkFDRjtnQkFDQSxJQUFJLENBQUNXLElBQUlFLEVBQUUsRUFBRSxNQUFNLElBQUlDLE1BQU0sMkJBQXNDLE9BQVhILElBQUlJLE1BQU07Z0JBQ2xFLE1BQU1MO2dCQUNOZCxpQkFBaUI7Z0JBQ2pCQyxRQUFRLEVBQUU7Z0JBQ1ZJLGVBQWU7Z0JBQ2ZGLG9CQUFvQjtZQUN0QixFQUFFLE9BQU91QixLQUFLO2dCQUNaeEMsUUFBUUMsS0FBSyxDQUFDdUM7Z0JBQ2RsQixTQUFTO1lBQ1g7UUFDRjtJQUNGO0lBRUEzQyxnREFBU0E7cUNBQUM7WUFDUixJQUFJd0IsbUJBQW1CQSxnQkFBZ0JxRCxJQUFJLEVBQUU7Z0JBQzNDNUI7WUFDRjtRQUNGO29DQUFHO1FBQUN6QjtLQUFnQjtJQUVwQixPQUFPO1FBQ0xDO1FBQ0FFO1FBQ0FFO1FBQ0FHO1FBQ0FFO1FBQ0EvQjtRQUNBa0M7UUFDQUU7UUFDQUU7UUFDQW5CO1FBQ0FNO1FBQ0FLO1FBQ0FFO1FBQ0FDO1FBQ0FFO1FBQ0FFO1FBQ0FTO1FBQ0FzQjtRQUNBWDtRQUNBdUI7UUFDQXhDO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiSDpcXHd3d1xcR29tZXRVSVxcZ29tZXR1aVxcc3JjXFxhcHBcXGFkbWluXFxob29rc1xcdXNlTWVkaWFNYW5hZ2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9hcHAvYWRtaW4vaG9va3MvdXNlTWVkaWFNYW5hZ2VyLnRzXHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IE1lZGlhIH0gZnJvbSAnQC9hcHAvYWRtaW4vdHlwZXMvaW5kZXgnO1xyXG5pbXBvcnQgeyBFeHRlbmRlZFNlc3Npb24gfSBmcm9tICdAL3R5cGVzL25leHQtYXV0aCc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFBlbmRpbmdGaWxlIHtcclxuICBmaWxlOiBGaWxlO1xyXG4gIGZvbGRlcjogc3RyaW5nO1xyXG4gIHRhZ3M6IHN0cmluZ1tdO1xyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XHJcbiAgdGFnSW5wdXQ6IHN0cmluZztcclxufVxyXG5cclxuLy8gRm9uY3Rpb24gZGUgbm9ybWFsaXNhdGlvbiBkZXMgdGFnc1xyXG5jb25zdCBub3JtYWxpemVUYWdzID0gKHRhZ3M6IHN0cmluZ1tdIHwgc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCk6IHN0cmluZ1tdID0+IHtcclxuICBpZiAoIXRhZ3MpIHJldHVybiBbXTsgLy8gR8OocmUgbnVsbCBvdSB1bmRlZmluZWRcclxuICBpZiAoQXJyYXkuaXNBcnJheSh0YWdzKSkge1xyXG4gICAgcmV0dXJuIHRhZ3NcclxuICAgICAgLmZsYXRNYXAoKHRhZzogc3RyaW5nKSA9PiB0YWcuc3BsaXQoJywnKS5tYXAoKHQpID0+IHQudHJpbSgpKSlcclxuICAgICAgLmZpbHRlcigodCkgPT4gdC5sZW5ndGggPiAwKTtcclxuICB9XHJcbiAgY29uc3QgdHJpbW1lZCA9IHRhZ3MudHJpbSgpO1xyXG4gIGlmICh0cmltbWVkID09PSAnbnVsbCcgfHwgdHJpbW1lZCA9PT0gJycpIHJldHVybiBbXTsgLy8gR8OocmUgXCJudWxsXCIgb3UgY2hhw65uZSB2aWRlXHJcbiAgaWYgKHRyaW1tZWQuc3RhcnRzV2l0aCgnWycpICYmIHRyaW1tZWQuZW5kc1dpdGgoJ10nKSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZSh0cmltbWVkKTtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkKSkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZWRcclxuICAgICAgICAgIC5mbGF0TWFwKCh0YWc6IGFueSkgPT4gKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnID8gdGFnLnNwbGl0KCcsJykubWFwKCh0KSA9PiB0LnRyaW0oKSkgOiBbXSkpXHJcbiAgICAgICAgICAuZmlsdGVyKCh0KSA9PiB0Lmxlbmd0aCA+IDApO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgSlNPTiB0YWdzOicsIGUpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdHJpbW1lZC5zcGxpdCgvWyxcXHNdKy8pLm1hcCgodCkgPT4gdC50cmltKCkpLmZpbHRlcigodCkgPT4gdC5sZW5ndGggPiAwKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZWRpYU1hbmFnZXIoZXh0ZW5kZWRTZXNzaW9uOiBFeHRlbmRlZFNlc3Npb24gfCBudWxsKSB7XHJcbiAgY29uc3QgW21lZGlhLCBzZXRNZWRpYV0gPSB1c2VTdGF0ZTxNZWRpYVtdPihbXSk7XHJcbiAgY29uc3QgW3BlbmRpbmdGaWxlcywgc2V0UGVuZGluZ0ZpbGVzXSA9IHVzZVN0YXRlPFBlbmRpbmdGaWxlW10+KFtdKTtcclxuICBjb25zdCBbZm9sZGVycywgc2V0Rm9sZGVyc10gPSB1c2VTdGF0ZTx7IG5hbWU6IHN0cmluZzsgbWVkaWE6IE1lZGlhW10gfVtdPihbXHJcbiAgICB7IG5hbWU6ICdEb3NzaWVyIHByaW5jaXBhbCcsIG1lZGlhOiBbXSB9LFxyXG4gIF0pO1xyXG4gIGNvbnN0IFtjdXJyZW50Rm9sZGVyLCBzZXRDdXJyZW50Rm9sZGVyXSA9IHVzZVN0YXRlKCdEb3NzaWVyIHByaW5jaXBhbCcpO1xyXG4gIGNvbnN0IFtzZWxlY3RlZE1lZGlhLCBzZXRTZWxlY3RlZE1lZGlhXSA9IHVzZVN0YXRlPE1lZGlhIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgW3RhZ3MsIHNldFRhZ3NdID0gdXNlU3RhdGU8c3RyaW5nW10+KFtdKTtcclxuICBjb25zdCBbc2VsZWN0ZWRUYWdJbnB1dCwgc2V0U2VsZWN0ZWRUYWdJbnB1dF0gPSB1c2VTdGF0ZSgnJyk7XHJcbiAgY29uc3QgW2Rlc2NyaXB0aW9uLCBzZXREZXNjcmlwdGlvbl0gPSB1c2VTdGF0ZSgnJyk7XHJcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG5cclxuICAvLyBTeW5jaHJvbmlzZSB0YWdzIGV0IGRlc2NyaXB0aW9uIGxvcnNxdWUgc2VsZWN0ZWRNZWRpYSBjaGFuZ2UsIGF2ZWMgbG9ncyBkw6l0YWlsbMOpc1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoc2VsZWN0ZWRNZWRpYSkge1xyXG4gICAgICBjb25zb2xlLmxvZygnU2VsZWN0ZWQgbWVkaWEgY2hhbmdlZCAoYmVmb3JlIHVwZGF0ZSk6Jywge1xyXG4gICAgICAgIHNlbGVjdGVkTWVkaWEsXHJcbiAgICAgICAgY3VycmVudFRhZ3M6IHRhZ3MsXHJcbiAgICAgICAgY3VycmVudERlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcclxuICAgICAgfSk7XHJcbiAgICAgIGNvbnN0IG5ld1RhZ3MgPSBub3JtYWxpemVUYWdzKHNlbGVjdGVkTWVkaWEudGFncyk7XHJcbiAgICAgIGNvbnN0IG5ld0Rlc2NyaXB0aW9uID0gc2VsZWN0ZWRNZWRpYS5kZXNjcmlwdGlvbiB8fCAnJztcclxuICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIHRhZ3MgYW5kIGRlc2NyaXB0aW9uOicsIHsgbmV3VGFncywgbmV3RGVzY3JpcHRpb24gfSk7XHJcbiAgICAgIHNldFRhZ3MobmV3VGFncyk7XHJcbiAgICAgIHNldERlc2NyaXB0aW9uKG5ld0Rlc2NyaXB0aW9uKTtcclxuICAgICAgc2V0U2VsZWN0ZWRUYWdJbnB1dCgnJyk7IC8vIFLDqWluaXRpYWxpc2UgbCdpbnB1dCBkZXMgdGFnc1xyXG4gICAgICBjb25zb2xlLmxvZygnVXBkYXRlZCBzdGF0ZXM6JywgeyB0YWdzOiBuZXdUYWdzLCBkZXNjcmlwdGlvbjogbmV3RGVzY3JpcHRpb24gfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZygnTm8gc2VsZWN0ZWQgbWVkaWEsIHJlc2V0dGluZyBzdGF0ZXMnKTtcclxuICAgICAgc2V0VGFncyhbXSk7XHJcbiAgICAgIHNldERlc2NyaXB0aW9uKCcnKTtcclxuICAgICAgc2V0U2VsZWN0ZWRUYWdJbnB1dCgnJyk7XHJcbiAgICB9XHJcbiAgfSwgW3NlbGVjdGVkTWVkaWFdKTtcclxuXHJcbiAgY29uc3QgbG9hZE1lZGlhID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcgbWVkaWEuLi4nKTtcclxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goJy9hcGkvbWVkaWEnKTtcclxuICAgICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIG1lZGlhOiAke3Jlcy5zdGF0dXN9YCk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xyXG4gICAgICBjb25zb2xlLmxvZygnUmF3IG1lZGlhIGRhdGE6JywgZGF0YSk7IC8vIExvZyBjb21wbGV0IHBvdXIgdm9pciBsYSBzdHJ1Y3R1cmVcclxuICAgICAgY29uc3QgeyBtZWRpYTogbWVkaWFEYXRhIH0gPSBkYXRhO1xyXG4gICAgICAvLyBUcmFpdGVtZW50IGRlcyBtw6lkaWFzIGF2ZWMgbm9ybWFsaXNhdGlvbiBkZXMgdGFncyBldCBkZXNjcmlwdGlvblxyXG4gICAgICBjb25zdCBwcm9jZXNzZWRNZWRpYSA9IG1lZGlhRGF0YS5tYXAoKGl0ZW06IE1lZGlhKSA9PiAoe1xyXG4gICAgICAgIC4uLml0ZW0sXHJcbiAgICAgICAgdGFnczogbm9ybWFsaXplVGFncyhpdGVtLnRhZ3MpLCAvLyBWw6lyaWZpZSBpY2kgc2kgdGFncyBlc3QgZMOpZmluaVxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiBpdGVtLmRlc2NyaXB0aW9uIHx8ICcnLCAvLyBBc3N1cmUgdW5lIHZhbGV1ciBwYXIgZMOpZmF1dCBwb3VyIGRlc2NyaXB0aW9uXHJcbiAgICAgIH0pKTtcclxuICAgICAgY29uc29sZS5sb2coJ1Byb2Nlc3NlZCBtZWRpYSB3aXRoIHRhZ3MgYW5kIGRlc2NyaXB0aW9uOicsIHByb2Nlc3NlZE1lZGlhKTtcclxuICAgICAgc2V0TWVkaWEocHJvY2Vzc2VkTWVkaWEpO1xyXG4gICAgICB1cGRhdGVGb2xkZXJzKHByb2Nlc3NlZE1lZGlhKTsgLy8gVXRpbGlzZXIgbGVzIG3DqWRpYXMgdHJhaXTDqXMgaWNpXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgICBzZXRFcnJvcignRXJyZXVyIGxvcnMgZHUgY2hhcmdlbWVudCBkZXMgbcOpZGlhcycpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCB1cGRhdGVGb2xkZXJzID0gKG1lZGlhTGlzdDogTWVkaWFbXSkgPT4ge1xyXG4gICAgY29uc3QgZm9sZGVyTWFwOiB7IFtrZXk6IHN0cmluZ106IE1lZGlhW10gfSA9IHt9O1xyXG4gICAgbWVkaWFMaXN0LmZvckVhY2goKG1lZGlhSXRlbSkgPT4ge1xyXG4gICAgICBjb25zdCBmb2xkZXJOYW1lID0gbWVkaWFJdGVtLmFzc29jaWF0ZWRfd2l0aCB8fCAnRG9zc2llciBwcmluY2lwYWwnO1xyXG4gICAgICBpZiAoIWZvbGRlck1hcFtmb2xkZXJOYW1lXSkgZm9sZGVyTWFwW2ZvbGRlck5hbWVdID0gW107XHJcbiAgICAgIGZvbGRlck1hcFtmb2xkZXJOYW1lXS5wdXNoKG1lZGlhSXRlbSk7XHJcbiAgICB9KTtcclxuICAgIHNldEZvbGRlcnMoT2JqZWN0LmVudHJpZXMoZm9sZGVyTWFwKS5tYXAoKFtuYW1lLCBtZWRpYV0pID0+ICh7IG5hbWUsIG1lZGlhIH0pKSk7XHJcbiAgICBpZiAoIWZvbGRlck1hcFtjdXJyZW50Rm9sZGVyXSkge1xyXG4gICAgICBzZXRDdXJyZW50Rm9sZGVyKCdEb3NzaWVyIHByaW5jaXBhbCcpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IHVwbG9hZEZpbGVzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgZm9yIChjb25zdCBwZW5kaW5nRmlsZSBvZiBwZW5kaW5nRmlsZXMpIHtcclxuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xyXG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZXMnLCBwZW5kaW5nRmlsZS5maWxlKTtcclxuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ3VzZXJJZCcsIGV4dGVuZGVkU2Vzc2lvbiEudXNlci5pZCk7XHJcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKCd0eXBlJywgJ21lZGlhJyk7XHJcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKCdmb2xkZXInLCBwZW5kaW5nRmlsZS5mb2xkZXIpO1xyXG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZCgndGFncycsIEpTT04uc3RyaW5naWZ5KHBlbmRpbmdGaWxlLnRhZ3MpKTtcclxuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ2Rlc2NyaXB0aW9uJywgcGVuZGluZ0ZpbGUuZGVzY3JpcHRpb24pO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKCcvYXBpL3VwbG9hZHMnLCB7XHJcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgIGJvZHk6IGZvcm1EYXRhLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghcmVzLm9rKVxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdXBsb2FkIGZpbGUgJHtwZW5kaW5nRmlsZS5maWxlLm5hbWV9OiAke3Jlcy5zdGF0dXN9YCk7XHJcbiAgICAgIH1cclxuICAgICAgc2V0UGVuZGluZ0ZpbGVzKFtdKTtcclxuICAgICAgYXdhaXQgbG9hZE1lZGlhKCk7XHJcbiAgICAgIHNldEVycm9yKG51bGwpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgc2V0RXJyb3IoJ0VycmV1ciBsb3JzIGRlIGzigJl1cGxvYWQgZGVzIGZpY2hpZXJzJyk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IHNhdmVNZWRpYUVkaXRzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKHNlbGVjdGVkTWVkaWEpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2FwaS9tZWRpYScsIHtcclxuICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgICAgaWQ6IHNlbGVjdGVkTWVkaWEuaWQsXHJcbiAgICAgICAgICAgIGZvbGRlcjogY3VycmVudEZvbGRlcixcclxuICAgICAgICAgICAgdGFnczogdGFncyxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgfSksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSBtZWRpYTogJHtyZXMuc3RhdHVzfWApO1xyXG4gICAgICAgIGF3YWl0IGxvYWRNZWRpYSgpO1xyXG4gICAgICAgIHNldFNlbGVjdGVkTWVkaWEobnVsbCk7XHJcbiAgICAgICAgc2V0VGFncyhbXSk7XHJcbiAgICAgICAgc2V0RGVzY3JpcHRpb24oJycpO1xyXG4gICAgICAgIHNldFNlbGVjdGVkVGFnSW5wdXQoJycpO1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgc2V0RXJyb3IoJ0VycmV1ciBsb3JzIGRlIGxhIG1pc2Ugw6Agam91ciBkdSBtw6lkaWEnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoZXh0ZW5kZWRTZXNzaW9uICYmIGV4dGVuZGVkU2Vzc2lvbi51c2VyKSB7XHJcbiAgICAgIGxvYWRNZWRpYSgpO1xyXG4gICAgfVxyXG4gIH0sIFtleHRlbmRlZFNlc3Npb25dKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG1lZGlhLFxyXG4gICAgcGVuZGluZ0ZpbGVzLFxyXG4gICAgZm9sZGVycyxcclxuICAgIGN1cnJlbnRGb2xkZXIsXHJcbiAgICBzZWxlY3RlZE1lZGlhLFxyXG4gICAgdGFncyxcclxuICAgIHNlbGVjdGVkVGFnSW5wdXQsXHJcbiAgICBkZXNjcmlwdGlvbixcclxuICAgIGlzTG9hZGluZyxcclxuICAgIGVycm9yLFxyXG4gICAgc2V0UGVuZGluZ0ZpbGVzLFxyXG4gICAgc2V0Q3VycmVudEZvbGRlcixcclxuICAgIHNldFNlbGVjdGVkTWVkaWEsXHJcbiAgICBzZXRUYWdzLFxyXG4gICAgc2V0U2VsZWN0ZWRUYWdJbnB1dCxcclxuICAgIHNldERlc2NyaXB0aW9uLFxyXG4gICAgbG9hZE1lZGlhLFxyXG4gICAgdXBsb2FkRmlsZXMsXHJcbiAgICB1cGRhdGVGb2xkZXJzLFxyXG4gICAgc2F2ZU1lZGlhRWRpdHMsXHJcbiAgICBzZXRFcnJvcixcclxuICB9O1xyXG59Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVN0YXRlIiwibm9ybWFsaXplVGFncyIsInRhZ3MiLCJBcnJheSIsImlzQXJyYXkiLCJmbGF0TWFwIiwidGFnIiwic3BsaXQiLCJtYXAiLCJ0IiwidHJpbSIsImZpbHRlciIsImxlbmd0aCIsInRyaW1tZWQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJwYXJzZWQiLCJKU09OIiwicGFyc2UiLCJlIiwiY29uc29sZSIsImVycm9yIiwidXNlTWVkaWFNYW5hZ2VyIiwiZXh0ZW5kZWRTZXNzaW9uIiwibWVkaWEiLCJzZXRNZWRpYSIsInBlbmRpbmdGaWxlcyIsInNldFBlbmRpbmdGaWxlcyIsImZvbGRlcnMiLCJzZXRGb2xkZXJzIiwibmFtZSIsImN1cnJlbnRGb2xkZXIiLCJzZXRDdXJyZW50Rm9sZGVyIiwic2VsZWN0ZWRNZWRpYSIsInNldFNlbGVjdGVkTWVkaWEiLCJzZXRUYWdzIiwic2VsZWN0ZWRUYWdJbnB1dCIsInNldFNlbGVjdGVkVGFnSW5wdXQiLCJkZXNjcmlwdGlvbiIsInNldERlc2NyaXB0aW9uIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwic2V0RXJyb3IiLCJsb2ciLCJjdXJyZW50VGFncyIsImN1cnJlbnREZXNjcmlwdGlvbiIsIm5ld1RhZ3MiLCJuZXdEZXNjcmlwdGlvbiIsImxvYWRNZWRpYSIsInJlcyIsImZldGNoIiwib2siLCJFcnJvciIsInN0YXR1cyIsImRhdGEiLCJqc29uIiwibWVkaWFEYXRhIiwicHJvY2Vzc2VkTWVkaWEiLCJpdGVtIiwidXBkYXRlRm9sZGVycyIsImVyciIsIm1lZGlhTGlzdCIsImZvbGRlck1hcCIsImZvckVhY2giLCJtZWRpYUl0ZW0iLCJmb2xkZXJOYW1lIiwiYXNzb2NpYXRlZF93aXRoIiwicHVzaCIsIk9iamVjdCIsImVudHJpZXMiLCJ1cGxvYWRGaWxlcyIsInBlbmRpbmdGaWxlIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImFwcGVuZCIsImZpbGUiLCJ1c2VyIiwiaWQiLCJmb2xkZXIiLCJzdHJpbmdpZnkiLCJtZXRob2QiLCJib2R5Iiwic2F2ZU1lZGlhRWRpdHMiLCJoZWFkZXJzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/admin/hooks/useMediaManager.ts\n"));

/***/ })

});